package bfs;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

/*
 *  下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可 以通行的地方。

1 010000
2 000100
3 001001
4 110000
迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。
对于上面的迷宫，从入口开始，可以按DRRURRDDDR 的顺序通过迷宫， 一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。
对于下面这个更复杂的迷宫（30 行 50 列），请找出一种通过迷宫的方式， 其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。
请注意在字典序中D<L<R<U。（如果你把以下文字复制到文本文件中，请务 必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 maze.txt， 
内容与下面的文本相同）
 * 
 * 
 * 
 * 
 * 思路：简单的最短路径的宽搜  都是用队列都存储走过的节点  这里多了个回溯 和要记住上下左右 要按照字典序
 * 那么在走每个节点的上下左右的时候就要按照字典序D U L R来走 但是这里我是用从走到终点再倒回来回溯 所以去试探的顺序就也要反过来
 * 因为将每个从队列中取出来的放进栈里 但不是每一个都是符合的最短路径上要走的节点，
 * 所以要比较从栈里取出来的节点的上一个节点的坐标与当前取出来的节点的左边是否一致，
 * 不一致则继续从栈中取  一致的话就更新 且把节点中从上一步走过来的方向添加到字符串中
 */
public class 迷宫问题 {
	public static void main(String[] args) {
	
		
		String s = "01010101001011001001010110010110100100001000101010"
				+ "00001000100000101010010000100000001001100110100101"
				+ "01111011010010001000001101001011100011000000010000"
				+ "01000000001010100011010000101000001010101011001011"
				+ "00011111000000101000010010100010100000101100000000"
				+ "11001000110101000010101100011010011010101011110111"
				+ "00011011010101001001001010000001000101001110000000"
				+ "10100000101000100110101010111110011000010000111010"
				+ "00111000001010100001100010000001000101001100001001"
				+ "11000110100001110010001001010101010101010001101000"
				+ "00010000100100000101001010101110100010101010000101"
				+ "11100100101001001000010000010101010100100100010100"
				+ "00000010000000101011001111010001100000101010100011"
				+ "10101010011100001000011000010110011110110100001000"
				+ "10101010100001101010100101000010100000111011101001"
				+ "10000000101100010000101100101101001011100000000100"
				+ "10101001000000010100100001000100000100011110101001"
				+ "00101001010101101001010100011010101101110000110101"
				+ "11001010000100001100000010100101000001000111000010"
				+ "00001000110000110101101000000100101001001000011101"
				+ "10100101000101000000001110110010110101101010100001"
				+ "00101000010000110101010000100010001001000100010101"
				+ "10100001000110010001000010101001010101011111010010"
				+ "00000100101000000110010100101001000001000000000010"
				+ "11010000001001110111001001000011101001011011101000"
				+ "00000110100010001000100000001000011101000000110011"
				+ "10101000101000100010001111100010101001010000001000"
				+ "10000010100101001010110000000100101010001011101000"
				+ "00111100001000010000000110111000000001000000001011"
				+ "10000001100111010111010001000110111010101101111000";
		
		
			int[][] maze = new int[30][50];
			for(int i=0;i<30;i++) {
				for(int j=0;j<50;j++) {
					maze[i][j] = s.charAt(i*50+j)-'0';
					
				}
				
			}
			
			System.out.println(bfs(maze,30,50));

	}
	
	public static String bfs(int[][] maze,int row,int col) {
		int[][] stepArr = {{-1,0},{0,1},{0,-1},{1,0}};      // 字典顺序是下左右上 我这里最后倒序回溯路径 所以是上右左下
		String[] direction = {"U","R","L","D"};
		int[][] visit = new int[row][col];//标记是否访问过
		StringBuilder sb = new StringBuilder();
		
		Node node = new Node(0,0,-1,-1,0,null);
		Queue<Node> queue = new LinkedList();
		queue.offer(node);//把第一个点放进去
		Stack<Node> stack = new Stack(); //存从队列中取出来的
		
		while(!queue.isEmpty()) {
			Node head = queue.poll();
			
			stack.push(head);//放进栈 好回溯
			
			visit[head.x][head.y] = 1;//表示访问过了
			
			for(int i=0;i<stepArr.length;i++) {
				int newX = head.x+stepArr[i][0];
				int newY = head.y+stepArr[i][1];
				String d = direction[i];
				
				//bfs 边界范围内 且是0 而且没有访问过
				
				if(newX>=0 && newX<row && newY>=0 && newY<col && maze[newX][newY]==0 && visit[newX][newY]==0) {
					Node newNode = new Node(newX,newY,head.x,head.y,head.step+1,d);
					queue.offer(newNode);
				}
				
				//跳出循环 到了出口 回溯节点
				if(newX == row-1 && newY== col-1 &&maze[newX][newY]==0 &&visit[newX][newY]==0) {
					Node top = stack.pop(); //到出口的上一步的节点
					sb.append(d); //到出口的最后一步的方向
					
					sb.append(top.direction);//这个是倒数第二步的方向 由倒数第三个节点到倒数第二个节点的
				
					int preX = top.preX;
					int preY = top.preY;
					while(!stack.isEmpty()) {
						top = stack.pop();
						
						//如果取出来的节点的坐标与上一个节点的上一步坐标相同则表示是这条路径上的节点
						if(preX == top.x && preY == top.y) {
							if(top.direction!=null) {
								sb.append(top.direction);
								
							}
							
							//更新新的上一步节点位置
							preX = top.preX;
							preY = top.preY;
						}
						
						//倒着回溯 所以要翻转 而且在for循环中要按照反过来的字典序来搜 因为走过就标记了不可以再走了 所以这样肯定是最短路径的最小字典序情况
						
					}
					return sb.reverse().toString();
				}
			}
		}
		
		
		
		
		
		
		
		
		
		
		
		
		
		return null;
	}
}

class Node{
	int x;
	int y;
	int preX; //上一步的位置
	int preY;
	int step;
	String direction;

	public Node(int x,int y,int preX,int preY,int step,String direction) {
		this.x = x;
		this.y =y;
		this.preX=preX;
		this.preY = preY;
		this.step = step;
		this.direction = direction;
	}
}
